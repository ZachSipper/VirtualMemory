Zach Sipper
#811873218

Data Strctures/Implementation
#############################################
1. Page Table
   not much freedom here. there is only one answer. we are forced to use the inverse page table paging structure. The structs nessacary are provided. All i had to do to finish the implementation was: update the IPTE.VPN on successful hits, and implement the pagefualt handler.
   in the use case that there is a free frame available, first swap in from disk to physical, then update the page table entries affected and the inverse page table enry corresponding to the PTEs.
   In the use case that there was no free frame available, call find_replacement() to give the victim frame. Then, access that victim's IPTE to get access to it's PTE. Then, swap out the victim from physical to disk. After that, update the page table entry for the victim to INVALID. Then swap in the requested page, and update it to valid and update the PFN within it's PTE.

2. FIFO
   super easy, declared a global linked list using the provided doubly linked list structure. Then everytime pagefault handler is called, i create a new list node and add it to the tail of the list. When i need to get a victim frame, just remove the head of the list and use that PFN(frame number) effectively pulling the oldest of the frames, hence it was "first in".

3. LRU
   for this one, when you call is_page_hit() and the hit is successful, meaning the page is currently in physical memory, you remove that PFN node from the list and add it back to the tail of the list. Creating the notion that the list is in order form (head->tail):(least recently used->most recently used). So whenever pagefault handler is called, to keep the ordering, you simply remove the head of the list and use that PFN then place the new node at the tail of the list.